import {
  require_shim,
  require_with_selector
} from "./chunk-MZSDPDLF.js";
import {
  N,
  Te,
  i,
  m,
  n,
  ne,
  p,
  u,
  vt
} from "./chunk-B2ZEN7I5.js";
import {
  require_react
} from "./chunk-ADEDN3NY.js";
import {
  __toESM,
  init_shim
} from "./chunk-CP7VGQTR.js";

// node_modules/effector-react/effector-react.mjs
init_shim();
var import_react = __toESM(require_react(), 1);
var import_with_selector = __toESM(require_with_selector(), 1);
var import_shim2 = __toESM(require_shim(), 1);
function e(e2, t2, n3, r2) {
  let o2 = [Te.run({ fn: (e3) => t2(e3) })];
  if (r2 && o2.unshift(r2), n3) {
    let t3 = n({ node: o2 }), r3 = e2.graphite.id, u3 = n3.additionalLinks, s2 = u3[r3] || [];
    return u3[r3] = s2, s2.push(t3), () => {
      let e3 = s2.indexOf(t3);
      -1 !== e3 && s2.splice(e3, 1), vt(t3);
    };
  }
  {
    let t3 = n({ node: o2, parent: [e2], family: { owners: e2 } });
    return () => {
      vt(t3);
    };
  }
}
function t(e2, t2) {
  return t2.displayName = e2, t2;
}
function n2(t2, n3) {
  ne.store(t2) || R("expect useStore argument to be a store");
  let r2 = import_react.default.useCallback((r3) => e(t2, r3, n3), [t2, n3]), o2 = import_react.default.useCallback(() => V(t2, n3), [t2, n3]);
  return O(r2, o2, o2);
}
function r(t2, n3) {
  let r2 = ne.unit(t2), o2 = {};
  r2 ? o2 = { unit: t2 } : "@@unitShape" in t2 ? "function" == typeof t2["@@unitShape"] ? o2 = t2["@@unitShape"]() : R("expect @@unitShape to be a function") : o2 = t2;
  let u3 = Array.isArray(o2), s2 = import_react.default.useRef({ stale: 1, justSubscribed: 0, scope: n3 }), [l2, a2, i3, c2, f2] = import_react.default.useMemo(() => {
    s2.current.stale = 1;
    let e2 = Array.isArray(o2) ? [] : {}, t3 = [], r3 = [], u4 = [], l3 = [];
    for (let s3 in o2) {
      let a3 = o2[s3];
      ne.unit(a3) || R("expect useUnit argument to be a unit"), ne.event(a3) || ne.effect(a3) ? (e2[s3] = n3 ? N(a3, { scope: n3 }) : a3, u4.push(s3), l3.push(a3)) : (e2[s3] = null, t3.push(s3), r3.push(a3));
    }
    return [e2, t3, r3, u4, l3];
  }, [s2, n3, ...Object.keys(o2), ...Object.values(o2)]), p3 = import_react.default.useRef({ value: l2, storeKeys: a2, eventKeys: c2, eventValues: f2 }), d2 = import_react.default.useCallback((t3) => {
    let r3 = s2.current;
    r3.justSubscribed = 1;
    let o3 = () => {
      r3.stale || (r3.stale = 1, t3());
    }, u4 = Te.compute({ priority: "sampler", batch: 1 }), l3 = i3.map((t4) => e(t4, o3, n3, u4));
    return () => {
      l3.forEach((e2) => e2());
    };
  }, [i3, n3, p3, s2]), m3 = import_react.default.useCallback(() => {
    let e2, t3 = p3.current, o3 = s2.current, d3 = 0, m4 = t3.value, y2 = t3.storeKeys, h2 = t3.eventKeys, v2 = t3.eventValues, b2 = n3 !== o3.scope;
    if (o3.stale || o3.justSubscribed || b2) {
      d3 = !o3.justSubscribed || b2, e2 = u3 ? [...l2] : { ...l2 }, y2.length === a2.length && h2.length === c2.length || (d3 = 1);
      for (let t4 = 0; t4 < a2.length; t4++) {
        let r3 = V(i3[t4], n3), o4 = a2[t4];
        d3 || (d3 = y2.includes(o4) ? m4[o4] !== r3 : 1), e2[o4] = r3;
      }
      for (let e3 = 0; e3 < c2.length; e3++) {
        let t4 = f2[e3], n4 = c2[e3];
        d3 || (d3 = h2.includes(n4) ? v2[h2.indexOf(n4)] !== t4 : 1);
      }
    }
    return d3 && (t3.value = e2), t3.storeKeys = a2, t3.eventKeys = c2, t3.eventValues = f2, o3.stale = 0, o3.justSubscribed = !d3, o3.scope = n3, r2 ? t3.value.unit : t3.value;
  }, [d2, i3, f2, n3, p3, s2]);
  return O(d2, m3, m3);
}
function o([t2, n3], r2) {
  let o2, u3, s2, l2, a2 = L;
  n3 ? (o2 = n3, s2 = t2, l2 = []) : { fn: o2, store: s2, keys: l2, defaultValue: u3, updateFilter: a2 = L } = t2, ne.store(s2) || R("useStoreMap expects a store"), Array.isArray(l2) || R("useStoreMap expects an array as keys"), "function" != typeof o2 && R("useStoreMap expects a function");
  let i3 = import_react.default.useCallback((t3) => e(s2, t3, r2), [s2, r2]), c2 = import_react.default.useCallback(() => V(s2, r2), [s2, r2]), f2 = import_react.default.useRef(), p3 = import_react.default.useRef(), d2 = import_react.default.useRef(l2);
  return K(i3, c2, c2, (e2) => {
    if (f2.current !== e2 || !((e3, t3) => {
      if (!e3 || !t3 || e3.length !== t3.length)
        return 0;
      let n4 = 1;
      for (let r3 = 0; r3 < e3.length; r3++)
        if (e3[r3] !== t3[r3]) {
          n4 = 0;
          break;
        }
      return n4;
    })(d2.current, l2)) {
      let t3 = o2(e2, l2);
      void 0 === t3 && void 0 !== u3 && (t3 = u3), f2.current = e2, d2.current = l2, void 0 !== t3 && (p3.current = t3);
    }
    return p3.current;
  }, (e2, t3) => !a2(t3, e2));
}
function u2(e2, t2 = {}, n3) {
  let { open: o2, close: u3, set: s2 } = r({ open: e2.open, close: e2.close, set: e2.set }, n3), l2 = import_react.default.useMemo(() => ({ open: o2, close: u3, set: s2 }), [e2, o2]), a2 = import_react.default.useRef({ value: null, count: 0 });
  M(() => (l2.open(a2.current.value), () => l2.close(a2.current.value)), [l2]), ((e3, t3) => {
    if (e3 === t3)
      return 1;
    if ("object" == typeof e3 && null !== e3 && "object" == typeof t3 && null !== t3) {
      let n4 = Object.keys(e3), r2 = Object.keys(t3);
      if (n4.length !== r2.length)
        return 0;
      for (let r3 = 0; r3 < n4.length; r3++) {
        let o3 = n4[r3];
        if (e3[o3] !== t3[o3])
          return 0;
      }
      return 1;
    }
    return 0;
  })(a2.current.value, t2) || (a2.current.value = t2, a2.current.count += 1), M(() => {
    l2.set(a2.current.value);
  }, [a2.current.count]);
}
function s(e2) {
  let t2 = import_react.default.useContext(U);
  return e2 && !t2 && R("No scope found, consider adding <Provider> to app root"), t2;
}
function l(e2, t2) {
  return ((e3, t3) => {
    if (!t3)
      return e3;
    let n3 = ne.unit(e3) || "object" != typeof e3 ? { event: e3 } : e3;
    return import_react.default.useMemo(() => {
      if (ne.unit(e3))
        return N(e3, { scope: t3 });
      let n4 = Array.isArray(e3) ? [] : {};
      for (let r2 in e3)
        n4[r2] = N(e3[r2], { scope: t3 });
      return n4;
    }, [t3, ...Object.keys(n3), ...Object.values(n3)]);
  })(e2, s(null == t2 ? void 0 : t2.forceScope));
}
function a(e2, t2) {
  return n2(e2, s(null == t2 ? void 0 : t2.forceScope));
}
function i2(e2, t2) {
  return r(e2, s(null == t2 ? void 0 : t2.forceScope));
}
function c(e2, t2) {
  return o([e2, t2], s(null == e2 ? void 0 : e2.forceScope));
}
function f(e2, r2, u3) {
  return ((e3, r3, u4) => {
    let s2, l2, a2, i3 = [];
    "object" == typeof r3 && null !== r3 ? (r3.keys && (i3 = r3.keys), { fn: s2, getKey: l2, placeholder: a2 } = r3) : s2 = r3, ne.store(e3) || R("expect useList first argument to be a store"), "function" != typeof s2 && R("expect useList's renderItem to be a function"), Array.isArray(i3) || R("expect useList's keys to be an array");
    let c2 = import_react.default.useMemo(() => {
      let n3 = t(`${e3.shortName || "Unknown"}.Item`, (t2) => {
        let { index: n4, keys: r4, keyVal: s3, value: l3 } = t2;
        if (f2.current[1])
          return f2.current[0](l3, s3);
        let a3 = o([{ store: e3, keys: [n4, ...r4], fn: (e4, t3) => e4[t3[0]] }], u4);
        return f2.current[0](a3, n4);
      });
      return import_react.default.memo(n3);
    }, [e3, u4, !!l2]), f2 = import_react.default.useRef([s2, l2]);
    f2.current = [s2, l2];
    let p3 = import_react.default.useMemo(() => i3, i3);
    if (l2) {
      let t2 = n2(e3, u4);
      return 0 === t2.length && a2 ? a2 : t2.map((e4) => {
        let t3 = f2.current[1](e4);
        return import_react.default.createElement(c2, { keyVal: t3, key: t3, keys: p3, value: e4 });
      });
    }
    {
      let t2 = o([{ store: e3, keys: [e3], fn: (e4) => e4.length }], u4);
      return 0 === t2 && a2 ? a2 : Array.from({ length: t2 }, (e4, t3) => import_react.default.createElement(c2, { index: t3, key: t3, keys: p3 }));
    }
  })(e2, r2, s(null == u3 ? void 0 : u3.forceScope));
}
function p2(e2, t2 = {}, n3) {
  return u2(e2, t2, s(null == n3 ? void 0 : n3.forceScope));
}
function d(e2, n3) {
  function r2(e3) {
    let t2 = import_react.default.useRef(e3), r3 = a(o2);
    M(() => (s2({ props: t2.current, state: o2.getState() }), () => {
      l2({ props: t2.current, state: o2.getState() });
    }), []);
    let u4 = n3(e3, r3);
    return t2.current = e3, u4;
  }
  let o2;
  ne.store(e2) ? o2 = e2 : "object" == typeof e2 && null !== e2 ? o2 = m(e2) : R("shape should be a store or object with stores");
  let u3 = "Unknown";
  o2 && o2.shortName && (u3 = o2.shortName);
  let s2 = u(), l2 = u();
  return r2.mounted = s2, r2.unmounted = l2, t(`${u3}.View`, r2);
}
function m2(e2) {
  return d(e2, ({ children: e3 }, t2) => e3(t2));
}
function y(e2, t2) {
  let n3 = t2 ? e2 : e2[0];
  var r2;
  ((e3) => {
    if (!e3)
      throw Error("expect first argument be an object");
  })(G(r2 = n3) || ((e3) => "function" == typeof e3)(r2));
  let o2 = n3.or, u3 = n3.and;
  if (u3) {
    let n4 = t2 ? u3 : u3[0];
    if (G(n4) && "and" in n4) {
      let n5 = y(u3, t2);
      e2 = n5[0], o2 = { ...o2, ...n5[1] };
    } else
      e2 = u3;
  }
  return [e2, o2];
}
function h(e2, t2) {
  let n3 = t2 && G(r2 = t2[0]) && (r2.and || r2.or) ? t2 : [{ and: t2 }];
  var r2;
  let o2, [[u3, s2], l2] = y(n3), a2 = {}, i3 = {}, c2 = l2;
  var f2;
  return "string" == typeof u3 ? (i3 = { name: u3 }, G(f2 = s2) && "sid" in f2 || (a2 = s2 || {})) : ((e3) => G(e3) && ("domain" in e3 || "defaultState" in e3 || "name" in e3))(u3) && (i3 = u3, a2 = u3.defaultState || {}, o2 = u3.domain), { hook: e2, domain: o2, defaultState: a2, mainConfig: i3, maybeConfig: c2 };
}
function v(...e2) {
  return (({ domain: e3, defaultState: n3, hook: r2, mainConfig: o2, maybeConfig: u3 }) => {
    function l2(e4) {
      return r2(l2, e4, s()), null;
    }
    let a2 = W({ or: u3, and: o2 }), i3 = `${e3 ? `${e3.compositeName.fullName}/` : ""}${a2.name || "gate"}`, c2 = u({ name: `${i3}.set`, sid: a2.sid ? `${a2.sid}|set` : void 0 }), f2 = u({ name: `${i3}.open`, sid: a2.sid ? `${a2.sid}|open` : void 0 }), p3 = u({ name: `${i3}.close`, sid: a2.sid ? `${a2.sid}|close` : void 0 }), d2 = p(Boolean(0), { name: `${i3}.status`, serialize: "ignore" }).on(f2, () => Boolean(1)).on(p3, () => Boolean(0)), m3 = p(n3, { name: `${i3}.state`, sid: a2.sid }).on(c2, (e4, t2) => t2).on(f2, (e4, t2) => t2).reset(p3);
    if (e3) {
      let { hooks: t2 } = e3;
      i({ target: [t2.store, t2.store, t2.event, t2.event, t2.event], params: [d2, m3, f2, p3, c2] });
    }
    return l2.open = f2, l2.close = p3, l2.status = d2, l2.state = m3, l2.set = c2, t(`Gate:${i3}`, l2);
  })(h(u2, e2));
}
var R = (e2) => {
  throw Error(e2);
};
var M = "undefined" != typeof window ? import_react.default.useLayoutEffect : import_react.default.useEffect;
var { useSyncExternalStore: O } = import_shim2.default;
var { useSyncExternalStoreWithSelector: K } = import_with_selector.default;
var V = (e2, t2) => t2 ? t2.getState(e2) : e2.getState();
var L = (e2, t2) => e2 !== t2;
var U = import_react.default.createContext(null);
var { Provider: B } = U;
var I = (e2) => console.error(`${e2} is deprecated`);
var P = (e2, n3, r2) => (I("createContextComponent"), t(`${e2.shortName || "Unknown"}.ContextComponent`, (t2) => {
  let o2 = import_react.default.useContext(n3), u3 = a(e2);
  return r2(t2, u3, o2);
}));
var z = (e2) => (n3) => {
  let r2 = e2;
  return "function" != typeof e2 && (r2 = n3, n3 = e2), t(`Connect(${r2.displayName || r2.name || "Unknown"})`, (e3) => import_react.default.createElement(r2, { ...e3, ...a(n3) }));
};
var F = (e2, t2) => (I("createReactState"), z(t2)(e2));
var G = (e2) => "object" == typeof e2 && null !== e2;
var W = (e2, t2 = {}) => (G(e2) && (W(e2.or, t2), ((e3) => {
  for (let o2 in e3)
    r2 = o2, ((e4) => void 0 === e4)(n3 = e3[o2]) || "or" === r2 || "and" === r2 || (t2[r2] = n3);
  var n3, r2;
})(e2), W(e2.and, t2)), t2);
export {
  B as Provider,
  z as connect,
  d as createComponent,
  P as createContextComponent,
  v as createGate,
  F as createReactState,
  m2 as createStoreConsumer,
  l as useEvent,
  p2 as useGate,
  f as useList,
  a as useStore,
  c as useStoreMap,
  i2 as useUnit
};
//# sourceMappingURL=effector-react.js.map
